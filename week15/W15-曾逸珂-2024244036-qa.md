## Q01：KMP算法 next数组的求解方法、时间复杂度

- prompt：请解释在KMP算法中，next数组是怎么求的，时间复杂度是如何确定的
- model_name：ChatGPT
- model_version：GPT-4o
- response：
KMP（Knuth-Morris-Pratt）算法的 `next` 数组用于表示模式串中每个位置的**部分匹配值**。它在匹配失败时，指示模式串应移动到哪里以继续匹配，从而避免重复计算，提升效率。

---

### 1. **`next` 数组的定义**

`next[i]` 表示**模式串的前缀和后缀的最长公共部分的长度**，但必须是**真子集**。比如，对于模式串 `P`：

- 前缀是从第一个字符开始到第 `i-1` 个字符的所有子串。
- 后缀是从第二个字符开始到第 `i` 个字符的所有子串。

#### 示例

对于模式串 `P = "ABABC"`：

- 对于前 1 个字符 `'A'`：没有真前缀和后缀，`next[1] = 0`。
- 对于前 2 个字符 `'AB'`：前缀是 `'A'`，后缀是 `'B'`，没有公共部分，`next[2] = 0`。
- 对于前 3 个字符 `'ABA'`：前缀是 `'A', 'AB'`，后缀是 `'A', 'BA'`，最长公共部分是 `'A'`，`next[3] = 1`。
- 对于前 4 个字符 `'ABAB'`：前缀是 `'A', 'AB', 'ABA'`，后缀是 `'B', 'AB', 'BAB'`，最长公共部分是 `'AB'`，`next[4] = 2`。
- 对于前 5 个字符 `'ABABC'`：前缀和后缀没有公共部分，`next[5] = 0`。

**`next` 数组结果：`[0, 0, 0, 1, 2]`**

---

### 2. **如何计算 `next` 数组**

计算 `next` 数组的步骤如下：

#### 初始化

令 `j = 0` 表示前缀的末尾，`i = 1` 表示后缀的末尾（从模式串的第二个字符开始计算 `next`）。

#### 核心逻辑

对于每个 `i`：

1. **当 `P[i] == P[j]`（前后缀相等）：**
    - 令 `j += 1`，然后 `next[i] = j`。
2. **当 `P[i] != P[j]`（匹配失败）：**
    - 回溯到上一个可能的匹配位置：`j = next[j-1]`。
    - 如果回溯后 `P[i] == P[j]`，则继续执行匹配；否则，令 `next[i] = 0`。

#### 步骤

1. 初始化 `next[0] = 0`。
2. 遍历模式串，从 `i = 1` 到 `len(P)-1`，逐步更新 `next[i]`。

#### 示例

对于模式串 `P = "ABABC"`：

- 初始化：`next[0] = 0`。
- `i = 1`，`P[1] ('B') ≠ P[0] ('A')`，所以 `next[1] = 0`。
- `i = 2`，`P[2] ('A') == P[0] ('A')`，所以 `j = 1`，`next[2] = 1`。
- `i = 3`，`P[3] ('B') == P[1] ('B')`，所以 `j = 2`，`next[3] = 2`。
- `i = 4`，`P[4] ('C') ≠ P[2] ('A')`，回退到 `j = next[1] = 0`，然后 `next[4] = 0`。

最终 `next` 数组为 `[0, 0, 1, 2, 0]`。

---

### 3. **时间复杂度的确定**

KMP 算法求 `next` 数组的时间复杂度是 **O(n)**，其中 `n` 是模式串的长度。

#### 分析

- 每次字符匹配（`P[i] == P[j]`）时，`i` 和 `j` 都会递增。
- 如果字符不匹配（`P[i] != P[j]`），`j` 会通过 `next[j-1]` 回退，回退的次数总和不会超过 `i` 的增量。
- 因此，每个字符最多被访问两次（一次是前进，另一次是回退），总的时间复杂度是 **O(n)**。

---

### 4. **总结**

- **`next` 数组的计算**：通过前后缀的匹配实现，每次匹配失败通过回退减少冗余计算。
- **时间复杂度**：线性时间 **O(n)**，因为模式串中的每个字符至多被处理两次。

## Q02：KMP算法的基本步骤

- prompt：KMP算法的基本步骤是如何的，特别讲解一下求出 next 数组之后的匹配流程
- model_name：ChatGPT
- model_version：GPT-4o
- response：

KMP（Knuth-Morris-Pratt）算法的基本思想是利用模式串的 `next` 数组来避免重复比较，从而实现高效的字符串匹配。

以下是 KMP 算法的完整步骤，包括求解 `next` 数组和匹配流程的详细解释：

---

### **1. 计算 `next` 数组**

`next` 数组的计算已经在上文详细讲解，这里简单总结：

1. 初始化：`next[0] = 0`。
2. 遍历模式串 `P`，对于每个位置 `i`，如果 `P[i] == P[j]`，增加前后缀匹配长度 `j`；否则利用 `next[j-1]` 回退直到找到可匹配的前后缀或回退到 `0`。
3. 重复以上步骤，直到生成整个 `next` 数组。

例如，模式串 `P = "ABABC"`，`next` 数组为 `[0, 0, 1, 2, 0]`。

---

### **2. 匹配流程**

假设主串为 `T`，长度为 `n`；模式串为 `P`，长度为 `m`；`next` 数组已经求出。

#### 核心变量

- `i`：主串的当前位置。
- `j`：模式串的当前位置。

#### 匹配逻辑

1. 初始化：`i = 0`，`j = 0`。
2. 遍历主串 `T`，从 `i = 0` 到 `i = n-1`。
    - **当 `T[i] == P[j]`**：
        - 匹配成功，继续比较下一个字符，令 `i++`，`j++`。
        - 如果 `j == m`（模式串匹配结束），找到一个匹配位置，记录起始位置 `i - m`，然后重置 `j = next[j-1]`（继续寻找后续可能的匹配）。
    - **当 `T[i] != P[j]`**：
        - 如果 `j > 0`，利用 `next` 数组回退：`j = next[j-1]`，不移动 `i`。
        - 如果 `j == 0`，主串位置向后移动：`i++`。
3. 重复上述过程，直到 `i == n`。

#### 匹配流程示例

主串 `T = "ABABDABACDABABC"`，模式串 `P = "ABABC"`，`next = [0, 0, 1, 2, 0]`：

1. 初始：`i = 0, j = 0`。
2. 比较：
    - `T[0] == P[0]`，`i++, j++`。
    - `T[1] == P[1]`，`i++, j++`。
    - `T[2] == P[2]`，`i++, j++`。
    - `T[3] == P[3]`，`i++, j++`。
    - `T[4] != P[4]`，`j = next[3] = 2`（回退），不移动 `i`。
    - `T[4] == P[2]`，继续匹配。
    - 最终找到第一个匹配位置 `i - m = 0`。
3. 重置 `j` 后继续，找到第二个匹配位置。

最终结果：匹配位置 `[0, 10]`。

---

### **3. 时间复杂度分析**

#### 预处理（求 `next` 数组）

- 每个字符至多被访问两次（一次前进，一次回退）。
- 时间复杂度为 **O(m)**。

#### 匹配主串

- 每个字符至多被访问两次（一次比较，一次通过 `next` 数组回退）。
- 时间复杂度为 **O(n)**。

#### 总时间复杂度

- 预处理和匹配的复杂度相加：**O(n + m)**。

---

### **4. 总结**

KMP 的匹配流程利用 `next` 数组有效地回退模式串位置，避免冗余比较，具体流程是：

1. 遇到字符匹配时，主串和模式串同步移动。
2. 遇到字符不匹配时，根据 `next` 数组回退模式串位置，主串位置保持不变。
3. 若匹配完成后模式串已全部匹配，则记录位置并继续查找。

这种算法通过精巧的 `next` 数组计算和利用，保证了匹配效率始终为线性时间。

## Q03：KMP最坏时间复杂度的证明

- prompt：给一个例子，证明一下KMP最坏情况下的时间复杂度
- model_name：ChatGPT
- model_version：GPT-4o
- response
为了证明 KMP 算法的最坏情况下的时间复杂度为 O(n+m)O(n + m)O(n+m)，我们需要构造一个特定的例子，让算法经历尽可能多的回退操作，但同时确保每个字符只被访问两次（一次前进，一次回退）。

---

### **例子构造**

设：

- 主串 T="AAAAAAAAB"T = "AAAAAAAAB"T="AAAAAAAAB"，长度为 n=9n = 9n=9。
- 模式串 P="AAAAB"P = "AAAAB"P="AAAAB"，长度为 m=5m = 5m=5。

---

### **计算模式串的 `next` 数组**

1. 初始化 next[0]=0next[0] = 0next[0]=0。
2. 遍历模式串：
    - P[1]=P[0]P[1] = P[0]P[1]=P[0]，因此 next[1]=1next[1] = 1next[1]=1。
    - P[2]=P[1]P[2] = P[1]P[2]=P[1]，因此 next[2]=2next[2] = 2next[2]=2。
    - P[3]=P[2]P[3] = P[2]P[3]=P[2]，因此 next[3]=3next[3] = 3next[3]=3。
    - P[4]≠P[3]P[4] \neq P[3]P[4]=P[3]，回退到 next[3−1]=2next[3-1] = 2next[3−1]=2，仍不匹配，继续回退到 next[2−1]=1next[2-1] = 1next[2−1]=1，仍不匹配，最终 next[4]=0next[4] = 0next[4]=0。

`next` 数组为：0,1,2,3,00, 1, 2, 3, 00,1,2,3,0。

---

### **KMP 匹配过程**

1. 初始化 i=0i = 0i=0（主串索引），j=0j = 0j=0（模式串索引）。
    
2. 遍历主串 TTT：
    
    - 比较 T[i]T[i]T[i] 和 P[j]P[j]P[j]：
        - T[0]=P[0]=′A′T[0] = P[0] = 'A'T[0]=P[0]=′A′，匹配：i=1,j=1i = 1, j = 1i=1,j=1。
        - T[1]=P[1]=′A′T[1] = P[1] = 'A'T[1]=P[1]=′A′，匹配：i=2,j=2i = 2, j = 2i=2,j=2。
        - T[2]=P[2]=′A′T[2] = P[2] = 'A'T[2]=P[2]=′A′，匹配：i=3,j=3i = 3, j = 3i=3,j=3。
        - T[3]=P[3]=′A′T[3] = P[3] = 'A'T[3]=P[3]=′A′，匹配：i=4,j=4i = 4, j = 4i=4,j=4。
        - T[4]≠P[4]T[4] \neq P[4]T[4]=P[4]（主串字符为 'A'，模式串字符为 'B'），匹配失败。
            - 使用 `next` 数组回退：j=next[4−1]=next[3]=3j = next[4-1] = next[3] = 3j=next[4−1]=next[3]=3。
            - 比较 T[4]=P[3]=′A′T[4] = P[3] = 'A'T[4]=P[3]=′A′，匹配失败，再次回退：j=next[3−1]=next[2]=2j = next[3-1] = next[2] = 2j=next[3−1]=next[2]=2。
            - 再次比较 T[4]=P[2]=′A′T[4] = P[2] = 'A'T[4]=P[2]=′A′，匹配失败，回退：j=next[2−1]=next[1]=1j = next[2-1] = next[1] = 1j=next[2−1]=next[1]=1。
            - 再次比较 T[4]=P[1]=′A′T[4] = P[1] = 'A'T[4]=P[1]=′A′，匹配失败，回退：j=next[1−1]=next[0]=0j = next[1-1] = next[0] = 0j=next[1−1]=next[0]=0。
3. 继续匹配：
    
    - 从 T[4]T[4]T[4]，重新开始匹配：i=5,j=0i = 5, j = 0i=5,j=0。
    - T[5]=P[0]T[5] = P[0]T[5]=P[0]，匹配：i=6,j=1i = 6, j = 1i=6,j=1，依此类推。
    - 直到 T[7]=P[3]T[7] = P[3]T[7]=P[3]，再次失败，进入回退流程。
    - 最终 T[8]=P[4]T[8] = P[4]T[8]=P[4]，匹配成功。

---

### **时间复杂度分析**

在最坏情况下，每次模式串部分匹配失败时，`j` 会根据 `next` 数组回退。然而：

- 主串索引 iii 每次递增 1，总共递增 nnn 次。
- 模式串索引 jjj 的回退操作次数总和不会超过 nnn，因为 `j` 回退后总会匹配当前主串字符。

因此，每个主串字符最多被访问两次（一次匹配前进，一次回退处理），总体时间复杂度为：

O(n+m)O(n + m)O(n+m)

---

### **总结**

通过这个例子可以看到，尽管存在多次回退，主串字符和模式串字符总访问次数加起来仍然是线性的，因此 KMP 算法的最坏时间复杂度为 O(n+m)O(n + m)O(n+m)。

## Q04：后缀数组的应用场景

- prompt：后缀数组是如何应用到问题求解中的？举例子
- model_name：ChatGPT
- model_version：GPT-4o
- response
**后缀数组**是一种强大的字符串处理工具，它可以高效地解决许多字符串相关问题，比如子串查询、最长公共子串、重复子串问题等。后缀数组是一个存储字符串所有后缀的排序索引数组，通常伴随着 **高度数组**（Longest Common Prefix, LCP 数组）一起使用。

以下详细介绍后缀数组的应用及具体例子。

---

## **1. 子串判断**

### 问题

给定一个主串 SSS 和多个查询子串 Q1,Q2,… QkQ_1, Q_2, \ldots \, Q_kQ1​,Q2​,…Qk​，判断每个子串是否是 SSS 的子串。

### 解法

使用后缀数组和二分查找快速解决：

1. 构造后缀数组 SASASA 和 SSS 的后缀。
2. 对每个查询子串 QQQ，使用二分查找在 SASASA 指向的后缀中查找 QQQ 的位置。
3. 判断 QQQ 是否出现在后缀的前缀中。

### 时间复杂度

- 构造后缀数组：O(nlog⁡n)O(n \log n)O(nlogn)。
- 每次查询：O(mlog⁡n)O(m \log n)O(mlogn)（mmm 为子串长度）。

---

### **示例**

#### 输入：

- 主串 S="banana"S = \text{"banana"}S="banana"。
- 查询子串：Q="ana"Q = \text{"ana"}Q="ana"。

#### 步骤：

1. 后缀数组 SASASA：
    - 后缀排序：`{"a", "ana", "anana", "banana", "na", "nana"}`。
    - 对应 SA=[5,3,1,0,4,2]SA = [5, 3, 1, 0, 4, 2]SA=[5,3,1,0,4,2]。
2. 使用二分查找，在后缀数组对应的后缀中查找 Q="ana"Q = \text{"ana"}Q="ana"：
    - 找到 SA[1]=3SA[1] = 3SA[1]=3，对应后缀 S[3:]="ana"S[3:] = \text{"ana"}S[3:]="ana"，匹配成功。

---

## **2. 最长公共子串（LCS）**

### 问题

给定两个字符串 AAA 和 BBB，求它们的最长公共子串。

### 解法

1. 将两个字符串拼接为 S=A+#+BS = A + \# + BS=A+#+B，其中 #\## 是一个不存在的分隔符字符。
2. 构造 SSS 的后缀数组 SASASA 和高度数组 LCPLCPLCP。
3. 遍历 LCPLCPLCP，找到来自 AAA 和 BBB 的后缀中具有最大 LCPLCPLCP 值的位置。
4. 返回最长公共子串。

### 时间复杂度

- 构造后缀数组和 LCP：O(nlog⁡n)O(n \log n)O(nlogn)。

---

### **示例**

#### 输入：

- A="ABAB"A = \text{"ABAB"}A="ABAB"，B="BABA"B = \text{"BABA"}B="BABA"。

#### 步骤：

1. 拼接字符串 S = \text{"ABAB#BABA"}。
2. 构造后缀数组和 LCPLCPLCP：
    - 后缀排序：`{"#BABA", "ABAB", "AB#BABA", "B", "B#BABA", "BA", "BAB", "BABA"}`。
    - 对应 SA=[4,0,2,6,5,7,3,1]SA = [4, 0, 2, 6, 5, 7, 3, 1]SA=[4,0,2,6,5,7,3,1]。
    - 对应 LCP=[0,2,1,0,1,3,0]LCP = [0, 2, 1, 0, 1, 3, 0]LCP=[0,2,1,0,1,3,0]。
3. 遍历 LCPLCPLCP，最长值为 333，对应子串 "BAB"\text{"BAB"}"BAB"。

#### 输出：

最长公共子串为 "BAB"\text{"BAB"}"BAB"。

---

## **3. 重复子串问题**

### 问题

在字符串 SSS 中，找出出现次数最多的最长重复子串。

### 解法

1. 构造后缀数组和 LCP 数组。
2. 在 LCPLCPLCP 数组中找出最大值及其对应位置。
3. 最大值的子串即为最长重复子串。

### 时间复杂度

- 构造后缀数组和 LCP：O(nlog⁡n)O(n \log n)O(nlogn)。
- 遍历 LCPLCPLCP：O(n)O(n)O(n)。

---

### **示例**

#### 输入：

- S="banana"S = \text{"banana"}S="banana"。

#### 步骤：

1. 后缀数组和 LCPLCPLCP：
    - 后缀排序：`{"a", "ana", "anana", "banana", "na", "nana"}`。
    - SA=[5,3,1,0,4,2]SA = [5, 3, 1, 0, 4, 2]SA=[5,3,1,0,4,2]。
    - LCP=[0,1,3,0,0,2]LCP = [0, 1, 3, 0, 0, 2]LCP=[0,1,3,0,0,2]。
2. LCPLCPLCP 最大值为 333，对应后缀 SA[2]=1SA[2] = 1SA[2]=1，即 "ana"\text{"ana"}"ana"。

#### 输出：

最长重复子串为 "ana"\text{"ana"}"ana"。

---

## **4. 子串字典序排名**

### 问题

求字符串 SSS 的所有子串按照字典序排序后，第 kkk 小的子串。

### 解法

1. 构造后缀数组。
2. 利用 LCP 数组计算每个后缀贡献的不同子串个数。
3. 累计子串个数，找到第 kkk 小的子串所在的后缀位置。

### 时间复杂度

- 构造后缀数组和 LCP：O(nlog⁡n)O(n \log n)O(nlogn)。
- 查找第 kkk 小：O(n)O(n)O(n)。

---

### **示例**

#### 输入：

- S="banana"S = \text{"banana"}S="banana"，k=5k = 5k=5。

#### 步骤：

1. 后缀数组和 LCPLCPLCP：
    - SA=[5,3,1,0,4,2]SA = [5, 3, 1, 0, 4, 2]SA=[5,3,1,0,4,2]，LCP=[0,1,3,0,0,2]LCP = [0, 1, 3, 0, 0, 2]LCP=[0,1,3,0,0,2]。
2. 子串个数：
    - 后缀 S[SA[i]:]S[SA[i]:]S[SA[i]:] 的新子串个数为 len(S[SA[i]:]) - LCP[i]\text{len(S[SA[i]:]) - LCP[i]}len(S[SA[i]:]) - LCP[i]。
    - 累加得到子串总数： [1,4,3,6,2,1]累计和：[1,5,8,14,16,17][1, 4, 3, 6, 2, 1] \quad \text{累计和：} [1, 5, 8, 14, 16, 17][1,4,3,6,2,1]累计和：[1,5,8,14,16,17]
3. 第 5 小的子串位于 SA[1]=3SA[1] = 3SA[1]=3，子串为 "ana"\text{"ana"}"ana"。

#### 输出：

第 555 小的子串为 "ana"\text{"ana"}"ana"。

---

## **总结**

后缀数组通过对字符串的后缀排序，并结合高度数组（LCP）的信息，能够高效解决多种字符串问题，包括：

1. **子串判断**（二分查找）。
2. **最长公共子串**（结合 LCP）。
3. **重复子串问题**（通过 LCP 最大值）。
4. **子串字典序排名**（通过后缀排序和 LCP 统计子串个数）。

其构造时间复杂度通常为 O(nlog⁡n)O(n \log n)O(nlogn)，在许多问题中表现出色。

## Q05：其他字符串匹配算法

- prompt：除了KMP算法以外，还有哪些高效的字符串匹配算法
- model_name：ChatGPT
- model_version：GPT-4o
- response
字符串匹配是计算机科学中的一个重要课题，除了 **KMP** 算法之外，还有其他许多高效的字符串匹配算法。以下是一些常见且高效的字符串匹配算法，每种算法都适合不同的应用场景。

---

### **1. Rabin-Karp 算法**

#### 核心思想

Rabin-Karp 算法通过将字符串转换为哈希值，将字符串匹配问题转化为哈希值比较问题，从而提高效率。它利用滑动窗口技术计算主串中每个子串的哈希值，与模式串的哈希值进行比较。

#### 主要步骤

1. 计算模式串的哈希值。
2. 滑动窗口计算主串中每个等长子串的哈希值。
3. 如果哈希值匹配，再进行字符逐一比较（解决哈希冲突）。

#### 优点

- 理论上的平均时间复杂度为 O(n)O(n)O(n)。
- 对多模式匹配（同时搜索多个模式）表现很好。

#### 缺点

- 最坏情况时间复杂度为 O(n⋅m)O(n \cdot m)O(n⋅m)（出现大量哈希冲突时）。
- 对哈希函数的选择和计算方式敏感。

---

### **2. Boyer-Moore 算法**

#### 核心思想

Boyer-Moore 算法通过在模式串中从右向左匹配，并结合启发式规则（如坏字符规则和好后缀规则），尽可能跳过主串中的多余字符，从而减少匹配次数。

#### 主要步骤

1. **坏字符规则**：当出现不匹配时，利用坏字符在模式串中的位置决定下一步的移动距离。
2. **好后缀规则**：当部分匹配成功后，利用已匹配的部分信息决定下一步的移动距离。

#### 优点

- 平均时间复杂度为 O(n/m)O(n/m)O(n/m)，适合长模式串匹配。
- 实际应用中非常高效。

#### 缺点

- 预处理阶段（计算规则表）稍显复杂。
- 对小模式串或字符集较小时性能可能不如其他算法。

---

### **3. Aho-Corasick 算法**

#### 核心思想

Aho-Corasick 是一种用于多模式串匹配的算法，通过构造一个**有限状态自动机（Trie 树 + 失败指针）**，同时匹配多个模式串。

#### 主要步骤

1. 构造 Trie 树，将所有模式串插入。
2. 添加失败指针，使得在匹配失败时能快速跳转到下一个可能的模式。
3. 遍历主串，沿着自动机的路径移动，识别出所有模式串出现的位置。

#### 优点

- 时间复杂度为 O(n+m+k)O(n + m + k)O(n+m+k)，其中 kkk 是匹配的结果数。
- 支持多模式匹配，效率非常高。

#### 缺点

- 构造 Trie 树和失败指针需要额外的空间。
- 实现较为复杂。

---

### **4. Sunday 算法**

#### 核心思想

Sunday 算法是 Boyer-Moore 的改进版，通过关注主串滑动窗口的**下一个字符**，决定模式串的移动距离。

#### 主要步骤

1. 如果模式串与主串不匹配，检查主串中窗口后的第一个字符。
2. 如果该字符存在于模式串中，根据模式串中最右侧该字符的位置决定移动距离。
3. 如果该字符不在模式串中，则直接移动整个模式串的长度。

#### 优点

- 简单易实现。
- 时间复杂度为 O(n)O(n)O(n)。
- 对短模式串效果较好。

#### 缺点

- 在某些模式串中性能可能不如 Boyer-Moore。

---

### **5. Zhu-Takaoka 算法**

#### 核心思想

Zhu-Takaoka 是 Boyer-Moore 的优化版本，它同时考虑坏字符和模式串的后缀结构，利用双重散列和分块来优化匹配过程。

#### 优点

- 比 Boyer-Moore 更高效，尤其是在处理大字符集时。

#### 缺点

- 实现较为复杂。
- 对短模式串或小字符集优势不明显。

---

### **6. Two-Way 算法**

#### 核心思想

Two-Way 是一种线性时间复杂度的字符串匹配算法，它结合了 KMP 和 Boyer-Moore 的优点，能在模式串和主串的两端进行匹配。

#### 优点

- 时间复杂度为 O(n)O(n)O(n)。
- 适合于各种场景下的匹配问题。

#### 缺点

- 实现复杂度较高。

---

### **7. Wu-Manber 算法**

#### 核心思想

Wu-Manber 算法是一种高效的多模式匹配算法，它通过哈希表预处理模式串，并利用滑动窗口和位操作快速匹配。

#### 优点

- 适合多模式串匹配。
- 在文本检索和网络应用中表现优秀。

#### 缺点

- 对单模式串不如其他算法高效。

---

### **8. SIMD 优化算法**

在现代计算中，通过 SIMD（Single Instruction, Multiple Data）指令可以加速字符串匹配。这类算法通常结合位并行技术，能在处理大规模字符串时表现出色。例如：

- **Bitap 算法**（基于位操作的动态规划）。
- **Shift-Or 算法**（用于快速子串搜索）。

#### 优点

- 能充分利用硬件的并行计算能力。
- 时间复杂度为 O(n)O(n)O(n)。

#### 缺点

- 对硬件和字符集有一定要求。

---

### **总结与适用场景**

|**算法**|**时间复杂度**|**适用场景**|
|---|---|---|
|KMP|O(n+m)O(n + m)O(n+m)|单模式串，适合小字符集。|
|Rabin-Karp|O(n+m)O(n + m)O(n+m)|多模式串，哈希冲突较少时表现好。|
|Boyer-Moore|O(n/m)O(n/m)O(n/m)|长模式串匹配，尤其在大文本中效果显著。|
|Aho-Corasick|O(n+m+k)O(n + m + k)O(n+m+k)|多模式串匹配，尤其适合敏感词过滤。|
|Sunday|O(n)O(n)O(n)|短模式串匹配，简单高效。|
|Two-Way|O(n)O(n)O(n)|广泛应用，结合多种技术优化。|
|Wu-Manber|O(n+m)O(n + m)O(n+m)|多模式串匹配，尤其适合文本搜索引擎。|
|SIMD 优化|O(n)O(n)O(n)|适合大数据处理，硬件支持下表现优秀。|

根据实际应用场景选择合适的算法，能有效提高效率。