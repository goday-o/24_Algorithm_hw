---
title: [W15--ch02]高级算法大模型辅助学习
author:
    - name:张晓雯^[2024244005,计算机科学与技术]

# toc: false
# toc-title: "目录"

filters:
  - scholarly-metadata.lua
  - author-info-blocks.lua

---

**Q01：Qname**

- prompt：（包括完整的提示设计）序列对比方法包括点阵法，点阵分析是一种比较两个序列以寻找可能排序的方法，如何利用滑动窗口处理噪声？

- model_name：ChatGPT

- model_version：4o

- response：

  点阵法（Dot Matrix Method）在序列对比中，用于可视化两个序列间的相似性，帮助发现重复序列、序列对齐或保守区域。然而，点阵图可能包含许多噪声点（随机匹配点），使主要的匹配模式难以观察。通过引入滑动窗口技术，可以有效地处理这些噪声。以下是利用滑动窗口处理点阵分析噪声的具体方法：

  **1. 滑动窗口概述**

  滑动窗口在点阵分析中是通过一个固定大小的窗口（通常为 m×n）在点阵图上移动，对窗口内的内容进行统计或过滤操作，从而平滑随机噪声并突出真实模式。

  **2. 利用滑动窗口处理噪声的方法**

  **(1) 平均法（Mean Filtering）**

  - **原理**： 对滑动窗口内的点计算相似性得分的均值，剔除孤立的高噪声点。
  - 实现步骤：
    1. 定义窗口大小（例如 5×5）。
    2. 计算窗口内点值的平均值。
    3. 如果窗口中心的点值低于某阈值，则认为是噪声点，将其设为零。
  - **优点**： 平滑随机匹配点，突出密集区域。
  - **缺点**： 可能模糊边缘。

  **(2) 中值法（Median Filtering）**

  - **原理**： 对滑动窗口内点值排序，取中位数作为窗口中心点的新值，可以有效去除离散噪声点。
  - 实现步骤：
    1. 定义窗口大小。
    2. 将窗口内的点值排序。
    3. 用排序后的中位数替代中心点值。
  - **优点**： 保留主对角线特征，同时去除随机噪声。
  - **缺点**： 对大范围的噪声较难处理。

  **(3) 权重法（Weighted Filtering）**

  - **原理**： 对滑动窗口内的点值赋予权重，中心点或与对角线更接近的点权重更高，通过加权平均抑制边缘噪声。
  - 实现步骤：
    1. 定义窗口大小及权重矩阵（如高斯权重或对称权重）。
    2. 按权重计算窗口内点值的加权平均。
    3. 替换窗口中心点的值。
  - **优点**： 可以有效突出对角线特征，减少模式丢失。
  - **缺点**： 需要设计适当的权重矩阵。

  **(4) 局部一致性检测**

  - **原理**： 检测滑动窗口内点值的局部一致性，剔除窗口内随机分布的点，仅保留形成连续模式的区域。
  - 实现步骤：
    1. 定义窗口大小。
    2. 计算窗口内点的分布一致性（如计算点数密度或连续性）。
    3. 仅保留满足一定密度或连续性的点，剔除孤立点。
  - **优点**： 适用于检测间隔性模式。
  - **缺点**： 计算量较大。

  **3. 参数调整与噪声处理效果**

  - 窗口大小：
    - 小窗口（如 3×3）：保留细节但对噪声的抑制有限。
    - 大窗口（如 7×7）：有效抑制噪声，但可能丢失局部特征。
  - 阈值选择：
    - 设定相似性阈值（如点值密度阈值），以保留显著的匹配区域。

  **4. 具体示例**

  假设有两个序列 A="ACGTACGT"和 B="ACGTTGCA"，点阵图中可能的滑动窗口处理：

  1. **初始点阵图**：显示 A 和 B 的所有相似点。
  2. **滑动窗口平滑**：窗口对每个区域进行统计，过滤掉孤立点，仅保留连续区域，如对角线对应的显著模式。
  3. **结果**：噪声被削弱，主对角线更为清晰，辅助对角线（例如重复序列）也更易观察。

  通过滑动窗口处理点阵图的噪声，可以更清楚地发现序列间的显著匹配区域和保守模式，同时减少随机噪声对分析的干扰。这在基因组序列比对、进化分析等领域尤其重要。

  

- prompt：在处理过程中滑动窗口的移动方式是逐个像素移动，还是有步长地跳跃移动？移动步长对结果有何影响？

- response：

  滑动窗口在处理过程中可以采用两种移动方式：逐像素移动或带步长跳跃移动。选择具体方式和步长会显著影响结果的平滑程度、计算效率以及信息保留程度。以下是这两种方式及其影响的详细分析：

  **1. 滑动窗口移动方式**

  **(1) 逐像素移动（步长为1）**

  - 特点：
    - 滑动窗口以每次移动一个像素（或一个字符）的方式进行遍历。
    - 遍历范围完全覆盖整个点阵图或序列比对矩阵。
  - 优点：
    - 平滑效果最佳，能捕捉细微的模式和连续变化。
    - 噪声处理更精细，适用于高精度分析。
  - 缺点：
    - 计算量较大，处理较大的点阵图时可能效率较低。

  **(2) 有步长跳跃移动（步长 > 1）**

  - 特点：
    - 滑动窗口按设定步长跳跃移动（如步长为2或3），不逐像素遍历。
    - 跳跃移动会跳过部分像素点，但仍然覆盖大部分点阵区域。
  - 优点：
    - 计算效率高，适合处理大规模点阵图或长序列。
    - 更关注全局模式，忽略细微噪声。
  - 缺点：
    - 可能遗漏细小模式或局部特征。
    - 平滑效果可能不如逐像素移动。

  **2. 移动步长对结果的影响**

  **(1) 精细度**

  - 步长较小（如1或2）：
    - 平滑和噪声抑制效果更好。
    - 可以捕捉细节和较短的匹配区域。
    - 更适合发现短重复序列或局部一致性模式。
  - 步长较大（如5或更多）：
    - 更适合识别全局的长序列匹配或较大范围的模式。
    - 会忽略短的匹配和局部细节。

  **(2) 计算效率**

  - 步长越大，计算效率越高，因为滑动窗口操作的次数减少。
  - 对于大规模点阵图，较大的步长能显著降低计算时间，但需权衡是否会丢失重要信息。

  **(3) 平滑程度**

  - 步长越小，平滑效果越好，但可能过度模糊细节。
  - 步长越大，图像更接近原始形态，噪声抑制效果下降。

  **(4) 结果的模式识别**

  - **步长为1**：适合发现短序列间的精确匹配。
  - **步长为序列比对中的模式长度（如3或4）**：能更快聚焦于对齐长度一致的子序列。

  **3. 实际选择步长的建议**

  - 短序列比对或小点阵图：
    - 优先使用逐像素移动（步长1）以获取精确结果。
  - 长序列比对或大点阵图：
    - 选择适中的步长（如3或5）可以平衡计算效率与模式捕捉能力。
  - 动态调整步长：
    - 根据目标的分辨率需求，使用多种步长并比较结果（如多尺度分析）。

  **4. 具体应用实例**

  **序列对比点阵图**

  假设两段序列：

  - A="ACGTACGTACGT"
  - B="ACGTGCGTACGT"

  在点阵分析中：

  1. 逐像素移动（步长1）：
     - 可以清晰地看到完整的主对角线及其细微分支（如局部匹配）。
     - 噪声点会被更多平滑处理。
  2. 步长为3：
     - 点阵图的对角线更为稀疏，只显示较为显著的匹配区域。
     - 忽略了较短的分支和细微匹配，但减少了计算量。

  **5. 总结**

  - **逐像素移动（步长1）**：适合需要细粒度平滑和模式捕捉的任务。
  - **步长移动（步长 > 1）**：适合高效地处理大规模数据，并聚焦于全局模式。

  步长的选择应根据具体应用场景的需求进行调整。如果可能，逐像素移动和多步长移动可以结合使用，以获得全局与局部信息的平衡。

------

**Q02：Qname**

- prompt：（包括完整的提示设计）什么是动态规划方法？在成对序列比对中为何重要？

- model_name：ChatGPT

- model_version：4o

- response：

  **动态规划方法**是一种解决优化问题的算法思想，适用于具有**重叠子问题**和**最优子结构**特性的情况。它通过将问题分解为子问题并保存其结果，避免重复计算，从而提高效率。

  在**成对序列比对（pairwise sequence alignment）**中，动态规划是核心算法之一，常用于比对两条序列（如DNA、RNA或蛋白质序列），以确定它们之间的最佳匹配方式。

  **动态规划的关键思想**

  1. **分解问题**：将序列比对问题分解为子问题，通常是比对两个较短子序列。
  2. **建立矩阵**：构建一个二维矩阵，行和列分别表示两条序列的字符。
  3. **递归关系**：利用动态规划递推公式填充矩阵中的每个格子，每个格子的值取决于其周围格子值的组合（通常代表替换、插入、删除的操作）。
  4. **回溯路径**：填充完成后，从矩阵右下角回溯到左上角，找到最佳比对路径。

  **动态规划在成对序列比对中的应用**

  最常用的两种方法是：

  1. **全局比对（Needleman-Wunsch算法）**

     - 比较整条序列，从头到尾进行对齐。
     - 适用于长度相近的序列。

     **公式**：

     ![image-20241208185308649](F:\研究生-组\课程作业\高级算法\大模型\W15\image-20241208185308649.png)

  2. **局部比对（Smith-Waterman算法）**

     - 比较序列的局部区域，寻找最相似的片段。
     - 更适用于长度不同或部分相似的序列。

     **公式**（与全局比对类似，但增加了一个约束条件）：

     ![image-20241208185325193](F:\研究生-组\课程作业\高级算法\大模型\W15\image-20241208185325193.png)

  **动态规划的重要性**

  1. **优化计算效率**：通过存储子问题的结果，动态规划避免了指数级增长的复杂度，提升了比对效率。
  2. **保证最优解**：动态规划能够系统地探索所有可能的比对路径，找到全局或局部最优解。
  3. **处理插入和缺失**：序列中的插入、缺失或替换可以通过惩罚分值灵活处理，适应生物序列的变异特点。
  4. **普遍适用性**：动态规划不仅用于成对序列比对，还在多序列比对、结构预测等领域广泛应用。

  **总结**：动态规划方法在成对序列比对中至关重要，它为准确、高效地计算序列相似性提供了强有力的工具。在生物信息学领域，这种方法极大地推动了基因组序列分析和比较研究的进展。

  

- prompt：你回答的很好，如果提出一个示例，每一步结合进行叙述会更加棒

- response：

  感谢您的建议！我们以一个实际的示例来具体演示动态规划在成对序列比对中的应用，帮助更直观地理解每一步。

  **示例问题**

  我们要比对以下两条序列：

  - 序列1：`GATTACA`
  - 序列2：`GCATGCU`

  **得分规则**：

  - 匹配：+2
  - 不匹配：-1
  - 缺口（gap）：-2

  目标：利用动态规划进行**全局比对**，找出两序列的最佳比对方式。

  **第一步：初始化矩阵**

  构建一个（序列1长度+1）×（序列2长度+1）的二维矩阵，用于存储得分。第一行和第一列用于处理缺口。初始化如下：

  - **第一行**：假设序列1为空，填充缺口分数。
  - **第一列**：假设序列2为空，填充缺口分数。

  |       | -    | G    | C    | A    | T    | G    | C    | U    |
  | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | **-** | 0    | -2   | -4   | -6   | -8   | -10  | -12  | -14  |
  | **G** | -2   |      |      |      |      |      |      |      |
  | **A** | -4   |      |      |      |      |      |      |      |
  | **T** | -6   |      |      |      |      |      |      |      |
  | **T** | -8   |      |      |      |      |      |      |      |
  | **A** | -10  |      |      |      |      |      |      |      |
  | **C** | -12  |      |      |      |      |      |      |      |
  | **A** | -14  |      |      |      |      |      |      |      |

  **第二步：填充矩阵（递归公式）**

  使用以下公式更新矩阵中的每个格子：

  ![image-20241208190105790](F:\研究生-组\课程作业\高级算法\大模型\W15\image-20241208190105790.png)

  **填充步骤（示例点）：**

  1. 计算第一个格子（第2行，第2列）：

     - 对应序列字符：`G`（序列1）和`G`（序列2），匹配，得分 +2。
     - 选择最大值： max⁡(0+2,−2−2,−2−2)=2

     更新矩阵：

  |       | -    | G    | C    | A    | T    | G    | C    | U    |
  | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | **-** | 0    | -2   | -4   | -6   | -8   | -10  | -12  | -14  |
  | **G** | -2   | 2    |      |      |      |      |      |      |
  | **A** | -4   |      |      |      |      |      |      |      |
  | **T** | -6   |      |      |      |      |      |      |      |
  | **T** | -8   |      |      |      |      |      |      |      |
  | **A** | -10  |      |      |      |      |      |      |      |
  | **C** | -12  |      |      |      |      |      |      |      |
  | **A** | -14  |      |      |      |      |      |      |      |

  1. 填充剩余格子：按规则逐步递推，选择最大得分。完整填充后的矩阵如下：

  |       | -    | G    | C    | A    | T    | G    | C    | U    |
  | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  | **-** | 0    | -2   | -4   | -6   | -8   | -10  | -12  | -14  |
  | **G** | -2   | 2    | 0    | -2   | -4   | -6   | -8   | -10  |
  | **A** | -4   | 0    | 1    | 3    | 1    | -1   | -3   | -5   |
  | **T** | -6   | -2   | -1   | 1    | 5    | 3    | 1    | -1   |
  | **T** | -8   | -4   | -3   | -1   | 3    | 7    | 5    | 3    |
  | **A** | -10  | -6   | -5   | -1   | 1    | 5    | 6    | 4    |
  | **C** | -12  | -8   | -4   | -3   | -1   | 3    | 9    | 7    |
  | **A** | -14  | -10  | -6   | -2   | -2   | 1    | 7    | 8    |

  **第三步：回溯路径**

  从右下角（`8`）开始，回溯到左上角（`0`），寻找最佳比对路径：

  - **对角移动**：匹配或不匹配。
  - **上方或左方移动**：表示插入或缺失。

  **比对结果：**

  ```
  序列1：G A T T - A C A
  序列2：G C A T G C - U
  ```

  **总结**

  通过动态规划，我们不仅获得了最佳比对的得分（`8`），还得到了具体的比对方式。这种方法确保了计算的高效性和准确性，非常适合处理生物序列的比较问题！

------

**Q03：Qname**

- prompt：（包括完整的提示设计）动态规划方法中，如何处理序列中的重复元素？

- model_name：ChatGPT

- model_version：4o

- response：

  在动态规划（Dynamic Programming, DP）方法中，处理序列中的重复元素需要仔细设计状态和转移，以确保正确性和效率。以下是一些常见策略：

  1. **明确状态的定义**

  重复元素可能会导致状态重复，因此在定义状态时需要清晰而具体，避免因重复元素引起冗余计算。例如：

  - **状态表示需要区分不同子问题**：比如在求解子序列问题时，可以使用起点和终点来明确状态，避免重复计算。

  2. **使用去重机制**

  如果重复元素可能引起相同的状态重复，可以通过以下方法去重：

  - **通过哈希表或集合**：记录已经计算过的状态，避免重复计算。例如在递归或记忆化搜索中，用一个`set`或`dict`存储已访问的状态。
  - **限制选择范围**：在问题需要选择某些元素时，可以对选择范围进行限制，如排序后处理或者跳过相邻的重复元素。

  3. **动态规划表的设计**

  动态规划表应能够区分重复元素之间的不同情况。以下是两种常见问题的具体处理方式：

  **例1：最长递增子序列（LIS）**

  如果序列包含重复元素，我们希望记录不同子序列的状态：

  - 排序不必要，但需小心转移时是否会“跳跃”到错误的状态。
  - 在状态转移中，确保`dp[i]`只从比`nums[i]`小的元素转移。

  **例2：背包问题**

  在背包问题中，如果物品的权重和价值重复，可以：

  - 明确状态表示：比如用`dp[i][w]`表示前`i`件物品在容量`w`下的最大价值。
  - 确保物品只被选择一次，或者多次选择规则明确。

  4. **排序或分组简化问题**

  - 对序列中的元素排序，方便处理连续或重复元素。
  - 按某些条件（如值、位置）对重复元素分组，简化问题规模。

  5. **具体案例**

  以下是一个解决带有重复元素的例子——求**不包含重复子序列的和为目标值的子集问题**：

  ```python
  def subset_sum(nums, target):
      nums.sort()  # 排序以便跳过重复元素
      dp = [False] * (target + 1)
      dp[0] = True
  
      for num in nums:
          for j in range(target, num - 1, -1):  # 从后往前更新
              dp[j] = dp[j] or dp[j - num]
      return dp[target]
  ```

  此方法通过排序和逆向更新，确保每个元素只被处理一次，避免重复计算。

  通过以上策略，可以高效处理动态规划中序列的重复元素问题，同时保持算法的正确性和效率。

------

**Q04：Qname**

- prompt：（包括完整的提示设计）成对对比算法（如Needleman-Wunsch和Smith-Waterman）能否直接用于多重序列对比？

- model_name：ChatGPT

- model_version：4o

- response：

  成对对比算法（如Needleman-Wunsch和Smith-Waterman）设计的初衷是进行**两条序列的比对**，它们本身并不能直接用于多重序列比对（MSA，Multiple Sequence Alignment）。这是因为多重序列比对的目标是同时对多条序列进行比对，以找出它们的全局或局部相似性，同时最大化保留各序列间的共同特征。然而，成对比对算法的设计限制了它们在多重序列比对中的直接应用。

  **原因**

  1. **算法复杂性**：
     - 成对对比的时间复杂度为 O(mn)，其中 m 和 n 是两条序列的长度。直接扩展到多重序列比对，复杂度会随着序列数的增加呈指数增长，变为 O(L^N)，其中 L 是序列平均长度，N 是序列数。这在实际应用中不可行。
  2. **得分矩阵扩展问题**：
     - 成对比对依赖于二维得分矩阵，多重序列比对需要一个高维矩阵来表示多条序列的可能对齐方式。直接扩展这些算法会增加内存需求和计算复杂性。
  3. **全局 vs. 局部对比**：
     - Needleman-Wunsch 是全局对比算法，Smith-Waterman 是局部对比算法，而多重序列比对可能需要结合全局和局部信息以获得最优的多序列对齐。

  **如何结合成对对比算法实现多重序列比对？**

  尽管成对比对算法不能直接用于多重序列比对，它们可以通过以下方式间接应用：

  1. **渐进式比对（Progressive Alignment）**：
     - 渐进式算法（如 ClustalW 和 MUSCLE）基于成对对比的结果构建一个**指导树（guide tree）**，然后按照树的结构逐步进行多重比对。
     - 具体流程：
       1. 使用成对比对计算序列间的相似性（通常使用 Needleman-Wunsch 或 Smith-Waterman）。
       2. 基于相似性矩阵构建一个聚类树（如邻接法，Neighbor-Joining）。
       3. 按照树的结构从最相似的序列开始逐步对齐，直到所有序列都完成比对。
  2. **迭代比对（Iterative Refinement）**：
     - 在初始多重序列对比结果的基础上，迭代地使用成对比对算法优化局部区域。
  3. **动态规划扩展**：
     - 在多重比对中，可以利用动态规划扩展成对比对的思想（如考虑三条或更多序列间的动态规划），但效率通常不高，更多用于实验或理论分析。

  **实际建议**

  由于成对比对算法的直接扩展在多重比对中的效率和效果有限，现代多重比对工具（如 Clustal Omega、MUSCLE 和 MAFFT）更常用，它们结合了成对比对的思想和优化技术，如渐进式比对、迭代优化和启发式算法。如果你需要更高效的多重序列比对，建议直接使用这些工具或库。

  

- prompt：你回答的很全面，以下是一个小建议：在讨论算法复杂性时，可以进一步解释为什么成对对比算法的时间复杂度在扩展到多重序列比对时会呈指数增长，以及这种增长的影响。

- response：

  感谢你的建议！让我们进一步探讨 **成对对比算法在扩展到多重序列比对时时间复杂度指数增长的原因**，并阐明其影响。

  **成对对比扩展到多重序列比对的复杂性来源**

  成对比对算法（如 Needleman-Wunsch）的时间复杂度为 O(mn)，其中 m 和 n 是两条序列的长度。这是因为动态规划表的每个单元需要填充一次，而表的大小是 m×n。但在多重序列比对（MSA）中：

  1. **增加的维度**：
     - 多重序列比对要求在所有序列之间同时找到最佳对齐方式。对于 N 条长度为 L 的序列，这意味着我们需要填充一个 N-维动态规划表，其大小为 L^N。
     - 例如，三条序列的比对需要一个三维表，大小为 L×L×L=L^3。
  2. **计算路径的指数增长**：
     - 成对比对中，只需找到两条路径之间的最佳路径。而在多重序列比对中，路径的组合呈现指数增长：动态规划需要考虑所有序列的所有可能对齐方式（即所有可能的插入、删除和匹配的组合）。
     - 对于 N 条序列，计算可能的对齐方式数量为指数级 3^{L^N}（因为每个位置可以选择匹配、插入或删除）。

  **复杂性增长的影响**

  1. **计算资源需求**：

     - 时间需求

       ：随着序列数量增加，算法的运行时间会迅速变得无法接受。例如：

       - 两条序列长度为 100 时，动态规划需要计算 100×100=10,000 个单元；
       - 三条序列长度为 100 时，需要计算 100×100×100=1,000,000 个单元。

     - **内存需求**：高维动态规划表的内存占用也迅速增加。对于长度为 500 的 4 条序列，表的大小为 500^4 = 62.5 亿单元，难以在普通计算机上处理。

  2. **实际不可行性**：

     - 即便计算能力强如超级计算机，扩展到较长序列或序列数量更多时，指数增长的复杂性仍然让直接应用成对比对方法变得不切实际。

  **为什么渐进式和启发式方法能缓解这个问题？**

  为了解决指数复杂性问题，现代多重比对算法采取了折衷策略，避免直接求解全局最优解：

  1. **渐进式比对**：
     - 不构造完整的 N-维表，而是通过两两比对逐步增加序列。每一步的复杂性控制在 O(L^2)（成对比对的复杂性），有效降低总体计算需求。
  2. **启发式方法**：
     - 像 MAFFT 和 MUSCLE 等工具，通过估计序列之间的相似性或使用快速比对策略，跳过部分无关区域的计算，进一步优化时间。
  3. **降维策略**：
     - 有些方法通过构建指导树，分而治之，将复杂度从指数级降为近似多项式。

  **总结**

  成对对比算法的复杂性呈指数增长，主要因为多维动态规划表的构造和路径组合数量爆炸。这个增长直接导致无法在多序列比对中直接应用成对比对算法。现代 MSA 工具通过渐进式、启发式和降维策略大幅缓解了这一问题，但仍以牺牲全局最优解为代价。

------

**Q05：Qname**

- prompt：（包括完整的提示设计）如何将深度学习方法（如GNN、Transformer等）应用于序列比对？

- model_name：ChatGPT

- model_version：4o mini

- response：

  将深度学习方法（如图神经网络（GNN）和Transformer）应用于序列比对的研究正在迅速发展，下面是一些应用思路和方法：

  1. **基于图神经网络（GNN）的序列比对**

  GNN可以通过其图结构捕捉序列之间的关系，这对于序列比对尤为重要。具体的应用方式包括：

  - **表示学习**：将序列数据表示为图结构，其中序列中的元素（如核苷酸或氨基酸）作为图的节点，相邻的元素作为边。通过GNN模型，学习这些节点和边之间的复杂关系，从而优化比对任务。
  - **同源序列比对**：在同源序列比对中，可以使用GNN来捕捉序列中局部和全局的关系。GNN通过多层卷积操作来增强序列特征的表达，帮助捕捉长距离的依赖关系。
  - **优化比对算法**：传统的比对方法（如动态规划）往往需要手动定义得分矩阵，而GNN可以通过训练自动学习最优的相似度度量，从而改善比对的精度。

  2. **基于Transformer的序列比对**

  Transformer在处理序列数据时具有强大的能力，尤其是在捕捉长距离依赖关系方面。应用Transformer进行序列比对的方式包括：

  - **序列对齐**：Transformer的自注意力机制可以帮助在序列比对中有效地捕捉序列中各个位置之间的关系。使用自注意力机制，模型能够识别哪些位置之间的关系对比对结果最为重要，从而提高比对的效率和精度。
  - **编码-解码结构**：可以设计类似于BERT（Bidirectional Encoder Representations from Transformers）或T5（Text-to-Text Transfer Transformer）的模型，首先对序列进行编码，然后根据比对的目标生成相应的对齐结果。该方法可以同时考虑全局和局部信息，减少传统方法中基于规则的限制。
  - **预训练模型**：使用大规模的预训练语言模型（如BERT或GPT）来学习生物序列的表示，然后通过微调这些模型以执行具体的序列比对任务。这种方法能够通过深度学习自动从数据中学习到更加丰富的序列特征。

  3. **联合方法**

  - **GNN和Transformer结合**：可以结合GNN的图结构处理能力和Transformer的自注意力机制，在序列比对中同时考虑局部结构和全局依赖。这种方法通常通过多模态学习来进行序列比对，通过图神经网络捕捉序列的结构信息，通过Transformer捕捉长距离的序列依赖。

  4. **应用实例**

  - **AlphaFold**：虽然AlphaFold主要用于蛋白质结构预测，但其方法（特别是基于Transformer的部分）也可以应用于序列比对任务。其通过深度学习模型理解序列间的关系，并预测更精确的序列对齐。
  - **DeepAlign**：DeepAlign是一个基于深度学习的序列比对工具，使用卷积神经网络（CNN）来学习序列对比的信息，也可以考虑使用GNN和Transformer结构进行改进。

  **总结**

  GNN和Transformer为传统的序列比对任务带来了创新，它们通过强大的表示学习和依赖捕捉能力，可以在序列比对中实现更高的精度和效率。这些方法通常依赖于大规模数据集的训练，以自动化学习序列间复杂的依赖关系。
